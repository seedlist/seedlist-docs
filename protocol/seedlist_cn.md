中文 | [English](seedlist_en.md)
#### 一. 概述

私钥/助记词的安全，从根本上来说，是存储方、用户和黑客三方的攻防博弈；从防守的角度，我们应当假设：

1. 存储方完全可靠；
2. 用户的加密密钥足够强；
3. 加密过程足够安全；

如何让这种假设变成现实呢？在展开下面论述之前，我们需要先定义三个初始熵值：

spaceName:  用来标示用户密钥空间的名称，需要用户输入提供；例如，您可以使用一句印象深刻的诗句、您的某一个纪念日、您的某个证件的ID，甚至您的某一个最常用网站登录名等等；

label:  用来标示每个存储对象的别称，理论上可以是任意值，需要用户输入提供；例如 ethereum-privkey，bitcoin-privkey等等；

password:  用户用来生成密钥的起始密码值，需要用户输入提供，但这个值并不会直接作为加密密钥值使用；真正的加密密钥，会通过组合space name、label和password进行一些列的KDF操作，并在得到的结果中随机加入盐值。下文会对此展开说明。



#### 二. 存储方完全可靠

​	此处的私钥/助记词存储方，是一般意义上的存储方。它包括常见的中心化云存储、本机磁盘存储、硬件钱包存储、纸质存储、去中心化存储甚至大脑记忆等等；
​	同样的，我们需要对可靠做一个界定：只要用户完成了存储行为，那么在后续的任意时刻，都可以获得和存入内容无差别的原内容。 因此：随时可取、内容无差别是核心诉求；
​	基于对私钥/助记词存储可靠的定义，反观上述的林林总总存储方，总会或多或少的存在一些对可靠性的潜在威胁，无法达到100%；

​	考虑到私钥/助记词的存储体积非常小(纵然是加密后也会保持在几百字节)，目前看以太坊的合约存储区是可以完全满足上述的可靠性诉求；



#### 三. 加密强度

一般讲，在加密算法可靠的前提下，加密强度取决于两方面：

1. 密钥长度：即常见的输入的密钥位数；

   ```
   所以，在处理密钥长度的时候，要做长度验证，提示用户达到一定长度；至此，我们需要用户和我们一起努力，完成这个诉求，以便迈向高强度密钥的目的；
   从加密过程的角度来看，seedlist会通过加入盐值混淆的方式，促使最终的加密密钥达到可靠加密长度，暂时是64个字符；
   ```

2. 密钥的复杂度：即输入的密钥要尽可能包含各种字符，中英文大小写、数字、字符等；

   ```
   密钥的复杂度，seedlist的加密过程会通过混淆盐值的方式，基于随机算法加入若干字符，以此保证复杂度；
   ```



#### 四. 加密过程

基于 `概述`  中对spaceName、label及password的定义 ，我们将逐步进行以下加密衍生过程：

1. 生成密钥空间标识

   ```
   a. 对spaceName和label进行字符串拼接，并对拼接后的字符串取hash；
   
   b. 取hash值的前后4个字节，获得Int32整数；基于Int32整数，获取一个位于[32, 64]中的随机值 rand0；
  
   c. 再次对spaceName及label分别求两次hash，得到spacename_hash2和label_hash2；
 
   d. 将spacename_hash2及label_hash2轮换拼接，得到两个新字符串s1和s2；并基于s1和s2分别生成一个公私钥对p1和p2；

   e. 用p1 p2分别对s2及s1进行签名，将签名结果分别赋值给spacename_hash2及label_hash2；

   f. 将上述的c~e过程，循环递签rand0次(b步骤生成)；

   g. 经过f步骤后，我们会得到两个字符串，将两个字符串拼接后，求hash后得到最终的种子熵；

   h. 基于g步骤得到的种子熵，生成一个以太坊钱包地址，该地址便是密钥空间标示；
   ```

2. 加密label

   ```
   a. 对spaceName字符串取hash；
   
   b. 取hash值的前后4个字节，获得Int32整数；基于Int32整数，获取一个位于[8, 16]中的随机值 rand0；
  
   c. 对spaceName递归hash rand0次后，得到的结果为 hash0；
   
   d. 以hash0为基本熵值，从以下随机串中摘出32个字符顺序拼接成字符串作为salt值:
   CHARS="1qaz!QAZ2w?sx@WSX.(=]3ec#EDC/)P:4rfv$RF+V5t*IK<9og}b%TGB6OL>yhn^YHN-[d'_7ujm&UJ0p;{M8ik,l|";
  
   e. 以 hash0 为慢hash对象，以d步骤salt为盐值，基于scrypt算法求得最终hash作为密钥值；其中，N, r, p, dkLen 分别设置为：32，64，16，64;
 
   d. 基于e步的最终密钥，对label进行AES加密获得label密文；
   ```

3. 加密明文

   ```
   a. 对spaceName、label及password进行字符串拼接，并对拼接后的字符串取hash；
   
   b. 取hash值的前后4个字节，获得Int32整数；基于Int32整数，获取一个位于[0, 8]中的随机值 rand0；
  
   c. 对spaceName、label及password分别进行双hash操作，得到h1、h2、h3；
 
   d. 基于h1+h2、h2+h3及h3+h1作为种子值，分别生成三个公私钥对 p1 p2 p3;

   e. 用 p1 p2 p3分别对h2+h3、h3+h1及h1+h2进行签名，将签名后的结果再次分别赋值给h1 h2 h3

   f. 将上述c~e过程重复rand0次；

   g. 将经过rand0次操作后得到的h1 h2 h3进行拼接，并计算拼接后的hash值，记为hash0；

   h. 取hash0值的前后4个字节，获得Int32整数；基于Int32整数，获取一个位于[0, 8]中的随机值 rand1；

   i. 以rand1为步长，以下面字符串长度求模，将将模值处字符插入hash0；插入位置的计算方式为：对hash0求hash，并重复h步骤的算法过程得到随机值rand2；
       rand2即为插入位置；
   CHARS="1qaz!QAZ2w?sx@WSX.(=]3ec#EDC/)P:4rfv$RF+V5t*IK<9og}b%TGB6OL>yhn^YHN-[d'_7ujm&UJ0p;{M8ik,l|";
   h. 重复i步骤32次；
   j. 以最终得到的字符串(98字符)，作为为密钥，AES加密用户数据；
   ```

   

